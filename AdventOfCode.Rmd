---
title: "Advent Of Code 2021 R"
author: "Nicholas Jacob"
date: "12/1/2021"
output: html_document
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
library(readr)
library(tidyverse)
library(rvest)
library(stringr)
```

## Day 1

I'd like to try this challenge https://adventofcode.com/2021.  I at least caught it on the first day so let's see how it goes.  First I'll read in the data from the very first challenge.

We are supposed to compute how many increases there are from one to the next.

```{r}
df <- read.csv('inputDay1',header = FALSE)

counter <- 0
for (i in 2:length(df$V1)){
  if (df$V1[i]>df$V1[i-1]) counter = counter + 1
}

counter

```

for the second challenge of the day, I need to consider the sum of three measurements and then see if those are increasing or not.

```{r}
df2 <- df$V1[1:1998]+df$V1[2:1999]+df$V1[3:2000]

counter <- 0
for (i in 2:length(df2)){
  if (df2[i]>df2[i-1]) counter = counter + 1
}

counter
```

## Day 2

Figure out where your ship has gone!
```{r}
df <- read.csv('day2input',header = FALSE)

depth <- 0
horizontal <- 0

for (entry in df$V1){
  if (grepl('forward', entry, fixed = TRUE)) horizontal = horizontal + as.numeric(str_sub(entry,-1,-1))
  else if (grepl('down', entry, fixed = TRUE)) depth = depth + as.numeric(str_sub(entry,-1,-1))
  else if (grepl('up', entry, fixed = TRUE)) depth = depth - as.numeric(str_sub(entry,-1,-1))
}

depth*horizontal
```
Second part is confusing!
```{r}

depth <- 0
horizontal <- 0
aim <- 0

for (entry in df$V1){
  if (grepl('forward', entry, fixed = TRUE)) {horizontal = horizontal + as.numeric(str_sub(entry,-1,-1)) ;
  depth = depth + aim*as.numeric(str_sub(entry,-1,-1))}
  else if (grepl('down', entry, fixed = TRUE)) aim = aim + as.numeric(str_sub(entry,-1,-1))
  else if (grepl('up', entry, fixed = TRUE)) aim = aim - as.numeric(str_sub(entry,-1,-1))
}
depth*horizontal
```

## Day 3

On to day three.  Now I attempt to deal with binary in R.  I am supposed to find the most common bit (and the least common bit).

```{r}
df3 <- read.csv('day3input',header = F)

head(df3)
```

First thing I notice is that R interpreted these as unmerical and dropped the leading 0's.  I think I need those.

```{r}
df3 <- read.csv('day3input',header = F,colClasses="character")
head(df3)
```

That's better!  Now I want to grab the first bit of each.  I think I'll do an average since if the average is about 0.5 then 1 was most common and if less, 0 was.

```{r}
gamma = ""
epsilon = ""

for (i in 1:12){
sum = 0
for (entry in df3$V1) {
  sum = sum + as.numeric(str_sub(entry,i,i))
}
{if (sum>500){
  gamma = paste(gamma,"1",sep = "")
  epsilon = paste(epsilon,"0",sep = "")}
else {
  gamma = paste(gamma,"0",sep = "")
  epsilon = paste(epsilon,"1",sep = "") }}
}

gamma
```

Now I just need a function to convert the binary into decimal.

```{r}
sum1 = 0
for(i in 1:12){
  sum1 = sum1 + as.numeric(str_sub(gamma,13-i,13-i))*2**(i-1)
}


sum2 = 0
for(i in 1:12){
  sum2 = sum2 + as.numeric(str_sub(epsilon,13-i,13-i))*2**(i-1)
}
sum2*sum1
```

Now for part 2 of Day 3.  I need to find the most common bit and then keep only the numbers with that bit.  I'll repeat that process until only one number is left.

```{r}
list = df3$V1

for (i in 1:12){
  if (mean(as.numeric(str_sub(list,i,i)))>=0.5){
    list = list[ str_sub(list,i,i)== 1]
  }
  else {
    list = list[ str_sub(list,i,i)== 0]
  }
}
oxygen <- list
```

```{r}
list = df3$V1

for (i in 1:12){
  if (length(list)>1){
  if (mean(as.numeric(str_sub(list,i,i))) >=0.5){
    list = list[ str_sub(list,i,i) == 0]
  }
  else {
    list = list[ str_sub(list,i,i)== 1]
  }}
}
CO <- list
```

```{r}
sum1 = 0
for(i in 1:12){
  sum1 = sum1 + as.numeric(str_sub(oxygen,13-i,13-i))*2**(i-1)
}


sum2 = 0
for(i in 1:12){
  sum2 = sum2 + as.numeric(str_sub(CO,13-i,13-i))*2**(i-1)
}
sum2*sum1
1025264
1003024
```

## Day 4

This input is a little different with two parts, the calls for bingo and the cards.  I'll need to figure out how to deal with that.

```{r}
df4 <- read.csv('Day4input',header = F)
head(df4,10)
```

I am going to read the first row as a single list.
```{r}
calls <- as.vector(as.numeric(df4[1,]))
calls
boards <- as.vector(df4[2:501,1])

first <- as.numeric(str_sub(boards,1,2))
second <- as.numeric(str_sub(boards,4,5))
third <- as.numeric(str_sub(boards,7,8))
fourth <- as.numeric(str_sub(boards,10,11))
fifth <- as.numeric(str_sub(boards,13,14))



boards <- data.frame(first,second,third,fourth,fifth)
boards
```

Let's write a function that checks if you get a bingo horizontally.

```{r}
vertical_check <- function(singleBoard, call){
  for (i in 1:5){
    if (all(singleBoard[[i]] %in% call)){
      return(TRUE)
    }}
  return(FALSE)
}

vertical_check(boards[1:5,],c(83,30,53,64,26,1))
```

```{r}
horizontal_check <- function(singleBoard, call){
  for (i in 1:5){
    if (all(singleBoard[i,] %in% call)){
      return(TRUE)
    }}
  return(FALSE)
}
b <- boards[1:5,]
horizontal_check(b,c(83,11,47,61,2))
```

```{r}
getRemainingValues <- function(singleBoard, call){
  vals = as.vector(unlist(singleBoard))
  return(sum(vals[!(vals %in% call)]))
}
getRemainingValues(b,c(83,11,47,61,2))
sum(as.vector(unlist(b))[!(as.vector(unlist(b)) %in% c(83,11,47,61,2))])
```

```{r}
checkAllBoards <- function(allBoards,call){
 for (i in 1:100){
   start <- (5*(i-1)+1)
   stop <- 5*i
   if (horizontal_check(allBoards[start:stop,],call) | vertical_check(allBoards[start:stop,],call) )
     return(getRemainingValues(allBoards[start:stop,],call))
 } 
  return(0)
}

checkAllBoards(boards,c(83,30,53,64,26,1))

```

```{r}
i = 5
list <- calls[1:5]
while (checkAllBoards(boards,list)==0){
  i = i+1
  list <- c(list,calls[i])
}

checkAllBoards(boards,list)*list[i]
```

```{r}
checkAllBoards2 <- function(allBoards,call,notYetWon){
 for (i in notYetWon){
   start = (5*(i-1)+1)
   stop = 5*i
   if (horizontal_check(allBoards[start:stop,],call) | vertical_check(allBoards[start:stop,],call) )
     return(i)
 } 
  return(0)
}
```

```{r}
losers <- c(1:100)
list <- calls[1:2]
i = 2
while (length(losers)>1){
  while(checkAllBoards2(boards,list,losers)!=0){
    losers <- losers[!(losers %in% checkAllBoards2(boards,list,losers))]
  }
  i = i+1
  list <- c(list,calls[i])
  losers <- losers[!(losers %in% checkAllBoards2(boards,list,losers))]
}

losers
i


```
The last board to win is number 85.  Let's see when it finally wins!

```{r}
while (checkAllBoards2(boards,list,losers)==0){
  i = i+1
  list <- c(list,calls[i])
}
start <- (5*(85-1)+1)
stop <- 5*85
getRemainingValues(boards[start:stop,],list)*list[i]
```

## Day 5 Line Segments

```{r}
df5 <- read.csv('Day5Input',header = F)
x1 = df5$V1
y1 = as.numeric(str_sub(df5$V2,1,3))
x2 = as.numeric(str_sub(df5$V2,-3,-1))
y2 = df5$V3

df5 <- data.frame(x1,y1,x2,y2)
head(df5)
```

```{r}
slope <- function(row){
  return((row[4]-row[2])/(row[3]-row[1]))
}

slope(df5[1,])
```
First to get just the vertical or horizontal lines

```{r}
generateHorAndVertPoints <- function(row){
  xlist = c()
  ylist = c()
  if ((row[1]>row[3])&(row[2] == row[4])){
    xstart = row[3]
    xend = row[1]
    yint = row[4]
    xlist = c(xstart)
    ylist = c(yint)
    for (i in (xstart+1):xend){
      xlist <- c(xlist,i)
      ylist <- c(ylist,slope(row)*(i-xstart)+yint)
    }
  }
  else if ((row[1]<row[3])&(row[2] == row[4])){
    xstart = row[1]
    xend = row[3]
    yint = row[2]
    xlist = c(xstart)
    ylist = c(yint)
    for (i in (xstart+1):xend){
      xlist <- c(xlist,i)
      ylist <- c(ylist,slope(row)*(i-xstart)+yint)
    }
  }
  else if ((row[2]>row[4])&(row[1]==row[3])){  
    xstart = row[1]
    yint = row[4]
    yend = row[2]
    xlist = c(xstart)
    ylist = c(yint)
    for (i in (yint+1):yend){
      xlist <- c(xlist,xstart)
      ylist <- c(ylist,i)
    }
  }
  else if ((row[2]<row[4])&(row[1]==row[3])){  
    xstart = row[1]
    yint = row[2]
    yend = row[4]
    xlist = c(xstart)
    ylist = c(yint)
    for (i in (yint+1):yend){
      xlist <- c(xlist,xstart)
      ylist <- c(ylist,i)
    }
  }
  return(data.frame(xlist,ylist))
}

```

```{r}
allThePoints <- generateHorAndVertPoints(as.vector(unlist(df5[1,])))

for (i in 2:500){
  allThePoints <- rbind(allThePoints,generateHorAndVertPoints(as.vector(unlist(df5[i,]))))
}
```

```{r}
length(allThePoints$xlist)
```
```{r}
library(data.table)
count.dups <- function(DF){

  DT <- data.table(DF)
  DT[,.N, by = names(DT)]
}

allThePointsWithN <- count.dups(allThePoints)

allThePointsWithN[allThePointsWithN$N>1]
```


```{r}
generatePoints <- function(row){
  if (row[1]>row[3]){
    xstart = row[3]
    xend = row[1]
    yint = row[4]
    xlist = c(xstart)
    ylist = c(yint)
    for (i in (xstart+1):xend){
      xlist <- c(xlist,i)
      ylist <- c(ylist,slope(row)*(i-xstart)+yint)
    }
  }
  else if (row[1]<row[3]){
    xstart = row[1]
    xend = row[3]
    yint = row[2]
    xlist = c(xstart)
    ylist = c(yint)
    for (i in (xstart+1):xend){
      xlist <- c(xlist,i)
      ylist <- c(ylist,slope(row)*(i-xstart)+yint)
    }
  }
  else if (row[2]>row[4]){  
    xstart = row[1]
    yint = row[4]
    yend = row[2]
    xlist = c(xstart)
    ylist = c(yint)
    for (i in (yint+1):yend){
      xlist <- c(xlist,xstart)
      ylist <- c(ylist,i)
    }
  }
  else {  
    xstart = row[1]
    yint = row[2]
    yend = row[4]
    xlist = c(xstart)
    ylist = c(yint)
    for (i in (yint+1):yend){
      xlist <- c(xlist,xstart)
      ylist <- c(ylist,i)
    }
  }
  return(data.frame(xlist,ylist))
}

generatePoints(as.vector(unlist(df5[18,])))
as.vector(unlist(df5[18,]))
```

```{r}
allThePoints <- generatePoints(as.vector(unlist(df5[1,])))

for (i in 2:500){
  allThePoints <- rbind(allThePoints,generatePoints(as.vector(unlist(df5[i,]))))
}
```

```{r}
length(allThePoints$xlist)
```
```{r}

count.dups <- function(DF){

  DT <- data.table(DF)
  DT[,.N, by = names(DT)]
}

allThePointsWithN <- count.dups(allThePoints)

allThePointsWithN[allThePointsWithN$N>1]
```
```{r}
180512-161398
```